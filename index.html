<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Neo-Expressionism Symbol Overlay</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-color: #f9f9f9;
    }
    h1 {
      margin-bottom: 10px;
    }
    #controls {
      margin-bottom: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      margin: 10px;
      max-width: 100%;
      height: auto;
    }
    /* Hidden canvas for loading the uploaded image */
    #inputCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Neo-Expressionism Symbol Overlay</h1>
  <div id="controls">
    <input type="file" id="uploadImage" accept="image/*" />
    <button id="applyFilter" disabled>Apply Symbol Overlay</button>
  </div>

  <!-- Visible canvas where the image and symbols are shown -->
  <canvas id="outputCanvas" width="800" height="600"></canvas>
  <!-- Hidden canvas for loading the uploaded image -->
  <canvas id="inputCanvas"></canvas>

  <script>
    const uploadImage = document.getElementById("uploadImage");
    const applyFilterBtn = document.getElementById("applyFilter");
    const outputCanvas = document.getElementById("outputCanvas");
    const inputCanvas = document.getElementById("inputCanvas");
    const ctxOutput = outputCanvas.getContext("2d");
    const ctxInput = inputCanvas.getContext("2d");

    // A small library of shape-based symbols (no text)
    const symbols = [
      { shape: 'crown' },
      { shape: 'skull' },
      { shape: 'arrow' },
      { shape: 'star' }
      // Add more shapes here if you like (e.g., 'heart', 'lightningBolt', etc.)
    ];

    // Listen for image uploads
    uploadImage.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          // Draw the uploaded image on the hidden input canvas
          inputCanvas.width = img.width;
          inputCanvas.height = img.height;
          ctxInput.drawImage(img, 0, 0);

          // Resize the output canvas to match the uploaded image
          outputCanvas.width = img.width;
          outputCanvas.height = img.height;

          // Draw the original image on the output canvas
          ctxOutput.drawImage(img, 0, 0);

          // Enable the filter button once an image is loaded
          applyFilterBtn.disabled = false;
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // When the user clicks "Apply Symbol Overlay", we add random shape symbols
    applyFilterBtn.addEventListener("click", () => {
      applySymbolOverlay();
    });

    function applySymbolOverlay() {
      const width = outputCanvas.width;
      const height = outputCanvas.height;

      // Number of random symbols to place
      const numSymbols = 50; // Adjust to taste

      for (let i = 0; i < numSymbols; i++) {
        // Pick a random symbol
        const symbol = symbols[Math.floor(Math.random() * symbols.length)];

        // Random position, rotation, size
        const x = Math.random() * width;
        const y = Math.random() * height;
        const rotation = Math.random() * 2 * Math.PI;
        const size = 30 + Math.random() * 50; // 30..80 px

        // Random fill & stroke colors
        const fillColor = getRandomColor();
        const strokeColor = getRandomColor();

        drawSymbol(ctxOutput, symbol.shape, x, y, rotation, size, fillColor, strokeColor);
      }
    }

    // Draw the chosen shape
    function drawSymbol(ctx, shape, x, y, rotation, size, fillColor, strokeColor) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);

      ctx.lineWidth = 3; // thick outline
      ctx.fillStyle = fillColor;
      ctx.strokeStyle = strokeColor;

      ctx.beginPath();
      switch (shape) {
        case 'crown':
          drawCrownPath(ctx, size);
          break;
        case 'skull':
          drawSkullPath(ctx, size);
          break;
        case 'arrow':
          drawArrowPath(ctx, size);
          break;
        case 'star':
          drawStarPath(ctx, size);
          break;
        default:
          // fallback shape: a circle
          ctx.arc(0, 0, size / 2, 0, 2 * Math.PI);
          break;
      }
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }

    // Crown shape
    function drawCrownPath(ctx, size) {
      // Simple spiky crown with 3 peaks
      // 'size' is the total width; height ~ half of that
      ctx.moveTo(-size/2, 0);
      ctx.lineTo(-size/4, -size/2);
      ctx.lineTo(0, 0);
      ctx.lineTo(size/4, -size/2);
      ctx.lineTo(size/2, 0);
      ctx.lineTo(-size/2, 0);
    }

    // Skull shape (very rough)
    function drawSkullPath(ctx, size) {
      const radius = size / 2;

      // Main head circle
      ctx.moveTo(0, -radius);
      ctx.arc(0, 0, radius, -Math.PI / 2, 1.5 * Math.PI);

      // Left eye
      const eyeRadius = radius / 5;
      let eyeOffsetX = -radius / 3;
      let eyeOffsetY = -radius / 5;
      ctx.moveTo(eyeOffsetX + eyeRadius, eyeOffsetY);
      ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, 2 * Math.PI);

      // Right eye
      eyeOffsetX = radius / 3;
      ctx.moveTo(eyeOffsetX + eyeRadius, eyeOffsetY);
      ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, 2 * Math.PI);

      // Simple mouth (horizontal line + small vertical “teeth” lines)
      const mouthWidth = radius / 1.5;
      const mouthY = radius / 4;
      ctx.moveTo(-mouthWidth / 2, mouthY);
      ctx.lineTo(mouthWidth / 2, mouthY);

      // Add a few teeth
      for (let i = 1; i < 4; i++) {
        const toothX = -mouthWidth / 2 + (i * (mouthWidth / 4));
        ctx.moveTo(toothX, mouthY);
        ctx.lineTo(toothX, mouthY + eyeRadius / 2); // small vertical lines
      }
    }

    // Arrow shape
    function drawArrowPath(ctx, size) {
      // 'size' is length of the arrow
      ctx.moveTo(-size/2, 0);
      ctx.lineTo(size/4, 0);
      // arrowhead
      ctx.lineTo(size/4, -size/4);
      ctx.lineTo(size/2, 0);
      ctx.lineTo(size/4, size/4);
      ctx.lineTo(size/4, 0);
      ctx.lineTo(-size/2, 0);
    }

    // Star shape
    function drawStarPath(ctx, size) {
      // 5-pointed star
      const spikes = 5;
      const outerRadius = size / 2;
      const innerRadius = size / 4;
      let rot = Math.PI / 2 * 3;
      const cx = 0;
      const cy = 0;
      const step = Math.PI / spikes;

      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        let x = cx + Math.cos(rot) * outerRadius;
        let y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
    }

    // Returns a random color (RGB)
    function getRandomColor() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r}, ${g}, ${b})`;
    }
  </script>
</body>
</html>
