<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Neo-Expressionism Photo Filter</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-color: #f9f9f9;
    }
    h1 {
      margin-bottom: 10px;
    }
    #controls {
      margin-bottom: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      margin: 10px;
      max-width: 100%;
      height: auto;
    }
    /* Hidden canvas for processing */
    #inputCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Neo-Expressionism Photo Filter</h1>
  <div id="controls">
    <input type="file" id="uploadImage" accept="image/*" />
    <button id="applyFilter" disabled>Apply Neo-Expressionism Filter</button>
  </div>

  <!-- Visible canvas where the image is shown and painted -->
  <canvas id="outputCanvas" width="800" height="600"></canvas>
  <!-- Hidden canvas for loading the uploaded image -->
  <canvas id="inputCanvas"></canvas>

  <script>
    const uploadImage = document.getElementById("uploadImage");
    const applyFilterBtn = document.getElementById("applyFilter");
    const outputCanvas = document.getElementById("outputCanvas");
    const inputCanvas = document.getElementById("inputCanvas");
    const ctxOutput = outputCanvas.getContext("2d");
    const ctxInput = inputCanvas.getContext("2d");

    // Listen for image uploads
    uploadImage.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          // Draw the uploaded image on the hidden canvas for pixel data
          inputCanvas.width = img.width;
          inputCanvas.height = img.height;
          ctxInput.drawImage(img, 0, 0);

          // Resize the output canvas to match the uploaded image
          outputCanvas.width = img.width;
          outputCanvas.height = img.height;

          // Draw the original image on the output canvas
          ctxOutput.drawImage(img, 0, 0);

          // Enable the filter button once an image is loaded
          applyFilterBtn.disabled = false;
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Apply the neo-expressionist effect by drawing randomized brush strokes + paint splashes
    applyFilterBtn.addEventListener("click", () => {
      applyNeoExpressionism();
    });

    function applyNeoExpressionism() {
      const width = inputCanvas.width;
      const height = inputCanvas.height;

      // We keep the original image as the background, so we do NOT clear the canvas.

      // Grab the image data from the hidden canvas
      const inputImageData = ctxInput.getImageData(0, 0, width, height);
      const data = inputImageData.data;

      // Helper to get the color of a pixel at (x, y)
      function getPixel(x, y) {
        const index = (y * width + x) * 4;
        return {
          r: data[index],
          g: data[index + 1],
          b: data[index + 2],
          a: data[index + 3]
        };
      }

      // 1 stroke per 3,000 pixels => baseStrokes
      // multiplied by 1,000 => extremely dense coverage
      const baseStrokes = Math.floor((width * height) / 3000);
      const numStrokes = baseStrokes * 1000;

      // Brush stroke appearance
      const alphaFactor = 0.8;
      const minStrokeLen = 5;
      const maxStrokeLen = 20;
      const minStrokeWidth = 2;
      const maxStrokeWidth = 5;

      // 1) Draw the random brush strokes
      for (let i = 0; i < numStrokes; i++) {
        // Random position in the image
        const x = Math.floor(Math.random() * width);
        const y = Math.floor(Math.random() * height);

        const pixel = getPixel(x, y);
        // Multiply the pixel's alpha by alphaFactor for more opacity
        const color = `rgba(${pixel.r}, ${pixel.g}, ${pixel.b}, ${
          (pixel.a / 255) * alphaFactor
        })`;

        // Random stroke parameters
        const strokeLength =
          Math.random() * (maxStrokeLen - minStrokeLen) + minStrokeLen;
        const angle = Math.random() * 2 * Math.PI;
        const dx = Math.cos(angle) * strokeLength;
        const dy = Math.sin(angle) * strokeLength;
        const strokeWidth =
          Math.random() * (maxStrokeWidth - minStrokeWidth) + minStrokeWidth;

        ctxOutput.strokeStyle = color;
        ctxOutput.lineWidth = strokeWidth;
        ctxOutput.lineCap = "round";

        ctxOutput.beginPath();
        ctxOutput.moveTo(x, y);
        ctxOutput.lineTo(x + dx, y + dy);
        ctxOutput.stroke();
      }

      // 2) Add random red/orange paint splatters
      drawPaintSplashes(width, height);
    }

    // Draw a cluster of small circles to simulate a "paint splatter"
    function drawSplatter(cx, cy, color) {
      // Number of dots in one splatter
      const numDots = 5 + Math.floor(Math.random() * 6); // 5..10 dots
      for (let i = 0; i < numDots; i++) {
        // Random offset from the center (cx, cy)
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * 30; // up to 30px from center
        const x = cx + Math.cos(angle) * distance;
        const y = cy + Math.sin(angle) * distance;

        // Random radius for each dot
        const radius = 2 + Math.random() * 8; // 2..10 px

        ctxOutput.beginPath();
        ctxOutput.arc(x, y, radius, 0, 2 * Math.PI);
        ctxOutput.fillStyle = color;
        ctxOutput.fill();
      }
    }

    // Randomly place a certain number of red/orange splatters around the canvas
    function drawPaintSplashes(width, height) {
      // Adjust the number of splatters to your preference
      const numSplashes = 50;

      for (let i = 0; i < numSplashes; i++) {
        // Pick a random center
        const cx = Math.floor(Math.random() * width);
        const cy = Math.floor(Math.random() * height);

        // Randomly choose red or orange; random alpha for a more natural look
        const alpha = 0.6 + Math.random() * 0.4; // 0.6..1.0
        const colorChoice = Math.random() < 0.5 
          ? `rgba(255, 0, 0, ${alpha})`       // red
          : `rgba(255, 165, 0, ${alpha})`;    // orange

        // Draw the splatter
        drawSplatter(cx, cy, colorChoice);
      }
    }
  </script>
</body>
</html>
