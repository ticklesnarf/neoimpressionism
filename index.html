<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Neo-Expressionism Scribble Filter</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-color: #f9f9f9;
    }
    h1 {
      margin-bottom: 10px;
    }
    #controls {
      margin-bottom: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      margin: 10px;
      max-width: 100%;
      height: auto;
    }
    /* Hidden canvas for processing the uploaded image */
    #inputCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Neo-Expressionism Scribble Filter</h1>
  <div id="controls">
    <input type="file" id="uploadImage" accept="image/*" />
    <button id="applyFilter" disabled>Apply Scribble Overlay</button>
  </div>

  <!-- Visible canvas for the image & scribbles -->
  <canvas id="outputCanvas" width="800" height="600"></canvas>
  <!-- Hidden canvas for loading the uploaded image -->
  <canvas id="inputCanvas"></canvas>

  <script>
    const uploadImage = document.getElementById("uploadImage");
    const applyFilterBtn = document.getElementById("applyFilter");
    const outputCanvas = document.getElementById("outputCanvas");
    const inputCanvas = document.getElementById("inputCanvas");
    const ctxOutput = outputCanvas.getContext("2d");
    const ctxInput = inputCanvas.getContext("2d");

    // A small library of shapes/words for neo-expressionist scribbles
    // type 'text' -> draws text; type 'shape' -> draws a custom path
    const symbols = [
      { type: 'text', value: 'CROWN' },
      { type: 'text', value: 'X' },
      { type: 'text', value: 'SKULL' },
      { type: 'text', value: '??' },
      { type: 'text', value: 'ART' },
      { type: 'text', value: 'WILD' },
      { type: 'text', value: '!!!' },
      { type: 'shape', shape: 'crown' },
      { type: 'shape', shape: 'arrow' },
      { type: 'shape', shape: 'star' }
    ];

    // Listen for image uploads
    uploadImage.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          // Draw the uploaded image on the hidden input canvas
          inputCanvas.width = img.width;
          inputCanvas.height = img.height;
          ctxInput.drawImage(img, 0, 0);

          // Resize the output canvas to match the uploaded image
          outputCanvas.width = img.width;
          outputCanvas.height = img.height;

          // Draw the original image on the output canvas
          ctxOutput.drawImage(img, 0, 0);

          // Enable the filter button once an image is loaded
          applyFilterBtn.disabled = false;
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // When the user clicks "Apply Scribble Overlay", we add random shapes/words
    applyFilterBtn.addEventListener("click", () => {
      applyNeoExpressionistScribbles();
    });

    function applyNeoExpressionistScribbles() {
      const width = outputCanvas.width;
      const height = outputCanvas.height;

      // Number of random symbols to place
      const numSymbols = 50; // Adjust to taste

      for (let i = 0; i < numSymbols; i++) {
        // Pick a random symbol from our library
        const symbol = symbols[Math.floor(Math.random() * symbols.length)];

        // Random position, rotation, color, size
        const x = Math.random() * width;
        const y = Math.random() * height;
        const rotation = Math.random() * 2 * Math.PI;
        const color = getRandomColor();
        const size = 20 + Math.random() * 50; // 20..70 px

        // Draw the symbol
        drawSymbol(ctxOutput, symbol, x, y, rotation, color, size);
      }
    }

    // Draw either text or a shape, depending on 'symbol.type'
    function drawSymbol(ctx, symbol, x, y, rotation, color, size) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 3; // thick outlines

      if (symbol.type === 'text') {
        // Draw text
        ctx.font = `bold ${size}px sans-serif`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(symbol.value, 0, 0);

      } else if (symbol.type === 'shape') {
        // Draw a shape (e.g. crown, arrow, star)
        ctx.beginPath();
        switch (symbol.shape) {
          case 'crown':
            drawCrownPath(ctx, size);
            break;
          case 'arrow':
            drawArrowPath(ctx, size);
            break;
          case 'star':
            drawStarPath(ctx, size);
            break;
          default:
            // fallback
            ctx.arc(0, 0, size, 0, 2 * Math.PI);
            break;
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    // A rough "crown" shape path
    function drawCrownPath(ctx, size) {
      // Let's define a simple shape with three spikes
      // We'll treat 'size' as width. The shape's height ~ half of size.
      ctx.moveTo(-size/2, 0);
      ctx.lineTo(-size/4, -size/2);
      ctx.lineTo(0, 0);
      ctx.lineTo(size/4, -size/2);
      ctx.lineTo(size/2, 0);
      ctx.lineTo(-size/2, 0);
    }

    // A simple "arrow" shape path
    function drawArrowPath(ctx, size) {
      // 'size' is length of the arrow
      // We'll do a straight line with a triangular tip
      ctx.moveTo(-size/2, 0);
      ctx.lineTo(size/4, 0);
      // arrowhead
      ctx.lineTo(size/4, -size/4);
      ctx.lineTo(size/2, 0);
      ctx.lineTo(size/4, size/4);
      ctx.lineTo(size/4, 0);
      ctx.lineTo(-size/2, 0);
    }

    // A simple "star" shape path
    function drawStarPath(ctx, size) {
      // 5-pointed star
      const spikes = 5;
      const outerRadius = size/2;
      const innerRadius = size/4;
      let rot = Math.PI / 2 * 3;
      let cx = 0;
      let cy = 0;
      let step = Math.PI / spikes;

      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        let x = cx + Math.cos(rot) * outerRadius;
        let y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
    }

    // Returns a random bright-ish color
    function getRandomColor() {
      // You can adjust the range for more intense or more pastel colors
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r}, ${g}, ${b})`;
    }
  </script>
</body>
</html>
